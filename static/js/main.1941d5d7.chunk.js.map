{"version":3,"sources":["SortingAlgorithms/SortingAlgorithms.js","SortingVisualizer/SortingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["bubbleSort","arr","animations","len","length","anySwaps","i","j","push","temp","insertionSort","currentIndex","selectionSort","minIndex","mergeSort","mergeSortHelp","aux","lo","hi","mid","Math","floor","index","mergeSortCombine","slice","quickSort","quickSortHelp","partitionIndex","pivot","swapIndex","quickSortPartition","TIMEOUTS","SortingVisualizer","props","updateAnimationSpeed","e","value","parseInt","target","setState","animationSpeed","pow","updateBars","newValue","newWidth","newMargin","numBars","barWidth","barMargin","resetArray","state","array","this","randomIntFromInterval","results","SortingAlgorithms","sortedArray","arrayBars","document","getElementsByClassName","aIndexPrev","bIndexPrev","swap","aIndex","bIndex","aStyle","style","bStyle","aStylePrev","bStylePrev","updateColors","swapBars","disableButtons","resetColors","updateArrayState","newHeight","setTimeout","height","buttons","getElementsByTagName","sliders","getElementById","clearTimeout","backgroundColor","disabled","aColor","bColor","numAnimations","finishButton","testArrays","testResults","javaScriptSort","sort","a","b","bubbleSortArray","insertionSortArray","selectionSortArray","mergeSortArray","quickSortArray","arraysAreEqual","console","log","min","max","random","id","className","type","defaultValue","step","onInput","onClick","map","idx","key","width","margin","skipAnimations","React","Component","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.1941d5d7.chunk.js","sourcesContent":["// Bubble Sort implementation that returns both an array of animations + the sorted array.\r\nexport const bubbleSort = arr => {\r\n    const animations = [];\r\n    let len = arr.length;\r\n    let anySwaps = false;\r\n\r\n    // Each iteration swaps the greatest element to sorted position on the right.\r\n    for (let i = 0; i < len - 1; i++) {\r\n        anySwaps = false;\r\n        for (let j = 0; j < len - 1 - i; j++) {\r\n            animations.push([-1, j, j + 1])\r\n            if (arr[j] > arr[j + 1]) { // Swaps adjacent bars if left is greater than right.\r\n                animations.push([0, j + 1, j]);\r\n                animations.push([2, j + 1, j]);\r\n                anySwaps = true;\r\n                let temp = arr[j];\r\n                arr[j] = arr[j + 1];\r\n                arr[j + 1] = temp;\r\n            } else {\r\n                animations.push([0, j, j + 1]);\r\n            }\r\n        }\r\n\r\n        // Breaks if there were no swaps in the previous loop (array is sorted).\r\n        if (anySwaps === false) {\r\n            break;\r\n        }\r\n    }\r\n    return [\r\n        animations,\r\n        arr\r\n    ];\r\n}\r\n\r\n// Insertion Sort implementation that returns both an array of animations + the sorted array.\r\nexport const insertionSort = arr => {\r\n    const animations = [];\r\n    let len = arr.length;\r\n\r\n    // Iterates through all values of the array (excluding the first index).\r\n    for (let i = 1; i < len; i++) {\r\n        animations.push([-1, i, i]);\r\n        let currentIndex = i;\r\n        // Shifts the values in the array until the current value is sorted.\r\n        while (currentIndex - 1 >= 0 && arr[currentIndex] < arr[currentIndex - 1]) {\r\n            animations.push([0, currentIndex, currentIndex - 1]);\r\n            animations.push([1, currentIndex, currentIndex - 1]);\r\n            let temp = arr[currentIndex];\r\n            arr[currentIndex] = arr[currentIndex - 1];\r\n            arr[currentIndex - 1] = temp;\r\n            currentIndex--;\r\n        }\r\n    }\r\n\r\n    return [\r\n        animations,\r\n        arr\r\n    ];\r\n};\r\n\r\n// Selection Sort implementation that returns both an array of animations + the sorted array.\r\nexport const selectionSort = arr => {\r\n    const animations = [];\r\n\r\n    // Each iteration swaps the least element to sorted position on the left.\r\n    for (let i = 0; i < arr.length; i++) {\r\n        let minIndex = i;\r\n        for (let j = i + 1; j < arr.length; j++) {\r\n            if (arr[minIndex] > arr[j]) { // Updates minIdex if the current value is the new min. \r\n                animations.push([0, j, minIndex]);\r\n                minIndex = j;\r\n            } else {\r\n                animations.push([0, minIndex, j]);\r\n            }\r\n        }\r\n\r\n        animations.push([0, minIndex, i]);\r\n        animations.push([1, minIndex, i]);\r\n        let temp = arr[minIndex];\r\n        arr[minIndex] = arr[i];\r\n        arr[i] = temp;\r\n    }\r\n\r\n    return [\r\n        animations,\r\n        arr\r\n    ];\r\n};\r\n\r\n// Merge Sort implementation that returns both an array of animations + the sorted array.\r\nexport const mergeSort = (arr) => {\r\n    const animations = [];\r\n    mergeSortHelp(animations, arr, arr.slice(), 0, arr.length - 1);\r\n\r\n    return [\r\n        animations,\r\n        arr\r\n    ];\r\n};\r\n\r\n// Recursive helper method for Merge Sort.\r\nfunction mergeSortHelp(animations, arr, aux, lo, hi) {\r\n    if (lo < hi) { // Executes until lo and hi cross (divides the array).\r\n        let mid = Math.floor((lo + hi) / 2);\r\n        mergeSortHelp(animations, arr, aux, lo, mid);\r\n        mergeSortHelp(animations, arr, aux, mid + 1, hi);\r\n\r\n        mergeSortCombine(animations, arr, aux, lo, mid, hi);\r\n    }\r\n}\r\n\r\n// Merging helper method for Merge Sort.\r\nfunction mergeSortCombine(animations, arr, aux, lo, mid, hi) {\r\n    animations.push([-1, lo, hi]);\r\n    let index = lo;\r\n    let i = lo;\r\n    let j = mid + 1;\r\n    \r\n    // Sorts the two sections in their proper places in the auxillary array. \r\n    while (i <= mid && j <= hi) {\r\n        if (arr[i] <= arr[j]) {\r\n            animations.push([0, i, j]);\r\n            animations.push([1, index, index, arr[i]]);\r\n            aux[index++] = arr[i++];\r\n        } else {\r\n            animations.push([0, j, i]);\r\n            animations.push([1, index, index, arr[j]]);\r\n            aux[index++] = arr[j++];\r\n        }\r\n    }\r\n\r\n    /* Copies the largest elements in the first half to the aux array (if applicable).\r\n    Does not need to be done with the second half because they would already be in the\r\n    proper locations. */    \r\n    while (i <= mid) { \r\n        animations.push([1, index, index, arr[i]]);\r\n        aux[index++] = arr[i++];\r\n    }\r\n\r\n    // Copies relevant sections of the aux array to the main arr. \r\n    for (let i = lo; i <= hi; i++) {\r\n        arr[i] = aux[i];\r\n    }\r\n}\r\n\r\n// Quick Sort implementation that returns both an array of animations + the sorted array.\r\nexport const quickSort = (arr) => {\r\n    const animations = [];\r\n    quickSortHelp(animations, arr, 0, arr.length - 1);\r\n\r\n    return [\r\n        animations,\r\n        arr\r\n    ];\r\n};\r\n\r\n// Recursive helper method for Quick Sort.\r\nfunction quickSortHelp(animations, arr, lo, hi) {\r\n    if (lo < hi) {\r\n        var partitionIndex = quickSortPartition(animations, arr, lo, hi);\r\n\r\n        quickSortHelp(animations, arr, lo, partitionIndex - 1);\r\n        quickSortHelp(animations, arr, partitionIndex + 1, hi);\r\n    }\r\n}\r\n\r\n// Partition method for Quick Sort.\r\nfunction quickSortPartition(animations, arr, lo, hi) {\r\n    animations.push([-2, lo, hi]);\r\n    animations.push([-1, hi, hi]);\r\n    const pivot = arr[hi];\r\n    let swapIndex = lo;\r\n\r\n    // Iterates through the current partition.\r\n    for (let i = lo; i < hi; i++) {\r\n        // If the current element is smaller than the pivot, swap with the element at swapIndex.\r\n        if (arr[i] < pivot) {\r\n            animations.push([0, i, hi]);\r\n            animations.push([1, i, swapIndex]);\r\n            let temp = arr[i];\r\n            arr[i] = arr[swapIndex];\r\n            arr[swapIndex] = temp;\r\n            swapIndex++;\r\n        } else {\r\n            animations.push([0, hi, i]);\r\n        }\r\n    }\r\n    // Swaps pivot with current swapIndex (now elements to the left <= pivot <= elements to the right)\r\n    animations.push([2, hi, swapIndex]);\r\n    let temp = arr[hi];\r\n    arr[hi] = arr[swapIndex];\r\n    arr[swapIndex] = temp;\r\n    return swapIndex;\r\n}","import React from 'react';\r\nimport './SortingVisualizer.css';\r\nimport * as SortingAlgorithms from '../SortingAlgorithms/SortingAlgorithms.js'\r\n\r\nconst DEBUG = false;\r\n\r\nconst SORTED_MS = 1500;\r\n\r\n// Colors used in the sorting visualizer.\r\nconst PRIMARY_COLOR = '#484f8f';\r\nconst SELECTION_COLOR = '#a6c64c';\r\nconst HIGHER_NUM_COLOR = '#c80003';\r\nconst LOWER_NUM_COLOR = '#405d3a';\r\nconst SORTED_COLOR = '#488f4b';\r\nconst TIMEOUTS = [];\r\n\r\nexport default class SortingVisualizer extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            array: [],\r\n            animationSpeed: 128,\r\n            numBars: 39,\r\n            barWidth: 2.01923077,\r\n            barMargin: .14423077,\r\n        };\r\n    }\r\n\r\n    // Runs when the component is initially loaded.\r\n    componentDidMount() {\r\n        this.resetArray(this.state.numBars);\r\n    }\r\n\r\n    // Generates a random int array of length numBars.\r\n    resetArray(value) {\r\n        const array = [];\r\n\r\n        for (let i = 0; i < value; i++) {\r\n            array.push(this.randomIntFromInterval(5, 65));\r\n        }\r\n\r\n        array[this.randomIntFromInterval(0, value - 1)] = 65;\r\n\r\n        this.setState({ array });\r\n    }\r\n\r\n    // Handles animations for Bubble Sort.\r\n    bubbleSort() {\r\n        const results = SortingAlgorithms.bubbleSort(this.state.array.slice());\r\n        const animations = results[0];\r\n        const sortedArray = results[1];\r\n\r\n        const arrayBars = document.getElementsByClassName('array-bar');\r\n\r\n        let [aIndexPrev, bIndexPrev] = [this.state.numBars - 1, this.state.numBars - 1];\r\n\r\n        for (let i = 0; i < animations.length; i++) {\r\n            const [swap, aIndex, bIndex] = animations[i];\r\n\r\n            const aStyle = arrayBars[aIndex].style;\r\n            const bStyle = arrayBars[bIndex].style;\r\n            const aStylePrev = arrayBars[aIndexPrev].style;\r\n            const bStylePrev = arrayBars[bIndexPrev].style;\r\n\r\n            if (swap === -1) { // Highlights currently selected bars.\r\n                this.updateColors(aStyle, bStyle, SELECTION_COLOR, SELECTION_COLOR, aStylePrev, bStylePrev, i);\r\n            } else if (swap === 0) { // Comparing two bars.\r\n                this.updateColors(aStyle, bStyle, LOWER_NUM_COLOR, HIGHER_NUM_COLOR, aStylePrev, bStylePrev, i);\r\n            } else { // Swapping positions of two bars.\r\n                this.updateColors(aStyle, bStyle, HIGHER_NUM_COLOR, LOWER_NUM_COLOR, aStylePrev, bStylePrev, i);\r\n                this.swapBars(aStyle, bStyle, i);\r\n            }\r\n            aIndexPrev = aIndex;\r\n            bIndexPrev = bIndex;\r\n        }\r\n\r\n        this.disableButtons(animations.length);\r\n        this.resetColors(arrayBars, animations.length);\r\n        this.updateArrayState(sortedArray, animations.length);\r\n    }\r\n\r\n    // Handles animations for Insertion Sort.\r\n    insertionSort() {\r\n        const results = SortingAlgorithms.insertionSort(this.state.array.slice());\r\n        const animations = results[0];\r\n        const sortedArray = results[1];\r\n\r\n        const arrayBars = document.getElementsByClassName('array-bar');\r\n\r\n        let [aIndexPrev, bIndexPrev] = [this.state.numBars - 1, this.state.numBars - 1];\r\n\r\n        for (let i = 0; i < animations.length; i++) {\r\n            const [swap, aIndex, bIndex] = animations[i];\r\n\r\n            const aStyle = arrayBars[aIndex].style;\r\n            const bStyle = arrayBars[bIndex].style;\r\n            const aStylePrev = arrayBars[aIndexPrev].style;\r\n            const bStylePrev = arrayBars[bIndexPrev].style;\r\n\r\n            if (swap === -1) { // Highlights currently selected bar.\r\n                this.updateColors(aStyle, bStyle, SELECTION_COLOR, SELECTION_COLOR, aStylePrev, bStylePrev, i);\r\n            } else if (swap === 0) { // Comparing two bars.\r\n                this.updateColors(aStyle, bStyle, LOWER_NUM_COLOR, HIGHER_NUM_COLOR, aStylePrev, bStylePrev, i);\r\n            } else { // Swaps positions of two bars. \r\n                this.updateColors(aStyle, bStyle, HIGHER_NUM_COLOR, LOWER_NUM_COLOR, aStylePrev, bStylePrev, i);\r\n                this.swapBars(aStyle, bStyle, i);\r\n            }\r\n            aIndexPrev = aIndex;\r\n            bIndexPrev = bIndex;\r\n        }\r\n\r\n        this.disableButtons(animations.length);\r\n        this.resetColors(arrayBars, animations.length);\r\n        this.updateArrayState(sortedArray, animations.length);\r\n    }\r\n\r\n    // Handles animations for Selection Sort.\r\n    selectionSort() {\r\n        const results = SortingAlgorithms.selectionSort(this.state.array.slice());\r\n        const animations = results[0];\r\n        const sortedArray = results[1];\r\n\r\n        const arrayBars = document.getElementsByClassName('array-bar');\r\n\r\n        if (DEBUG) console.log(animations);\r\n\r\n        // Variables used to track the swapped array indices.\r\n        let [aIndexPrev, bIndexPrev] = [this.state.numBars - 1, this.state.numBars - 1];\r\n\r\n        for (let i = 0; i < animations.length; i++) {\r\n            const [swap, aIndex, bIndex] = animations[i];\r\n\r\n            const aStyle = arrayBars[aIndex].style;\r\n            const bStyle = arrayBars[bIndex].style;\r\n            const aStylePrev = arrayBars[aIndexPrev].style;\r\n            const bStylePrev = arrayBars[bIndexPrev].style;\r\n\r\n            if (!swap) { // Comparing two bars.\r\n                if (DEBUG) console.log(\"Compare: \" + animations[i]);\r\n                this.updateColors(aStyle, bStyle, LOWER_NUM_COLOR, HIGHER_NUM_COLOR, aStylePrev, bStylePrev, i);\r\n            } else { // Swaps positions of two bars.\r\n                if (DEBUG) console.log(\"Swap: \" + animations[i]);\r\n                this.updateColors(aStyle, bStyle, HIGHER_NUM_COLOR, LOWER_NUM_COLOR, aStylePrev, bStylePrev, i);\r\n                this.swapBars(aStyle, bStyle, i);\r\n            }\r\n            aIndexPrev = aIndex;\r\n            bIndexPrev = bIndex;\r\n        }\r\n\r\n        this.disableButtons(animations.length);\r\n        this.resetColors(arrayBars, animations.length);\r\n        this.updateArrayState(sortedArray, animations.length);\r\n    }\r\n\r\n    // Handles animations for Merge Sort.\r\n    mergeSort() {\r\n        const results = SortingAlgorithms.mergeSort(this.state.array.slice());\r\n        const animations = results[0];\r\n        const sortedArray = results[1];\r\n\r\n        const arrayBars = document.getElementsByClassName('array-bar');\r\n\r\n        let [aIndexPrev, bIndexPrev] = [this.state.numBars - 1, this.state.numBars - 1];\r\n\r\n        for (let i = 0; i < animations.length; i++) {\r\n            const [state, aIndex, bIndex] = animations[i];\r\n\r\n            const aStyle = arrayBars[aIndex].style;\r\n            const bStyle = arrayBars[bIndex].style;\r\n            const aStylePrev = arrayBars[aIndexPrev].style;\r\n            const bStylePrev = arrayBars[bIndexPrev].style;\r\n\r\n            if (state === -1) { // Highlighting hi and lo.\r\n                this.updateColors(aStyle, bStyle, SELECTION_COLOR, SELECTION_COLOR, aStylePrev, bStylePrev, i);\r\n            } else if (state === 0) { // Comparing two bars from partitions.\r\n                this.updateColors(aStyle, bStyle, LOWER_NUM_COLOR, HIGHER_NUM_COLOR, aStylePrev, bStylePrev, i);\r\n            } else { // Updating bar at swapIndex with new height (can't fully visualize because of aux array).\r\n                this.updateColors(aStyle, bStyle, HIGHER_NUM_COLOR, LOWER_NUM_COLOR, aStylePrev, bStylePrev, i);\r\n                let newHeight = animations[i][3];\r\n\r\n                TIMEOUTS.push(setTimeout(() => {\r\n                    aStyle.height = `${newHeight}vh`;\r\n                }, i * this.state.animationSpeed));\r\n            }\r\n            aIndexPrev = aIndex;\r\n            bIndexPrev = bIndex;\r\n        }\r\n\r\n        this.disableButtons(animations.length);\r\n        this.resetColors(arrayBars, animations.length);\r\n        this.updateArrayState(sortedArray, animations.length);\r\n    }\r\n\r\n    // Handles animations for Quick Sort.\r\n    quickSort() {\r\n        const results = SortingAlgorithms.quickSort(this.state.array.slice());\r\n        const animations = results[0];\r\n        const sortedArray = results[1];\r\n\r\n        const arrayBars = document.getElementsByClassName('array-bar');\r\n\r\n        let [aIndexPrev, bIndexPrev] = [this.state.numBars - 1, this.state.numBars - 1];\r\n\r\n        for (let i = 0; i < animations.length; i++) {\r\n            const [state, aIndex, bIndex] = animations[i];\r\n\r\n            const aStyle = arrayBars[aIndex].style;\r\n            const bStyle = arrayBars[bIndex].style;\r\n            const aStylePrev = arrayBars[aIndexPrev].style;\r\n            const bStylePrev = arrayBars[bIndexPrev].style;\r\n\r\n            if (state === -2) { // Highlighting hi and lo of current partition. \r\n                if (DEBUG) console.log(\"lo: \" + aIndex + \" hi: \" + bIndex);\r\n                this.updateColors(aStyle, bStyle, SELECTION_COLOR, SELECTION_COLOR, aStylePrev, bStylePrev, i);\r\n\r\n            } else if (state === -1) { // Highlighting pivot index.\r\n                if (DEBUG) console.log(\"pivot: \" + aIndex);\r\n                this.updateColors(aStyle, bStyle, SELECTION_COLOR, SELECTION_COLOR, aStylePrev, bStylePrev, i);\r\n\r\n            } else if (state === 0) { // Comparing current bar with pivot.\r\n                if (DEBUG) console.log(\"comparison: [\" + aIndex + \", \" + bIndex + \"]\");\r\n                this.updateColors(aStyle, bStyle, LOWER_NUM_COLOR, HIGHER_NUM_COLOR, aStylePrev, bStylePrev, i);\r\n\r\n            } else if (state === 1) { // Swapping current selection with swap index if less than pivot\r\n                if (DEBUG) console.log(\"swapping: [\" + aIndex + \", \" + bIndex + \"]\");\r\n                this.updateColors(aStyle, bStyle, HIGHER_NUM_COLOR, LOWER_NUM_COLOR, aStylePrev, bStylePrev, i);\r\n                this.swapBars(aStyle, bStyle, i);\r\n\r\n            } else { // Swapping pivot bar with swap index. \r\n                if (DEBUG) console.log(\"swap pivot: [\" + aIndex + \", \" + bIndex + \"]\");\r\n                this.updateColors(aStyle, bStyle, PRIMARY_COLOR, PRIMARY_COLOR, aStylePrev, bStylePrev, i);\r\n                this.swapBars(aStyle, bStyle, i);\r\n\r\n            }\r\n            aIndexPrev = aIndex;\r\n            bIndexPrev = bIndex;\r\n        }\r\n\r\n        this.disableButtons(animations.length);\r\n        this.resetColors(arrayBars, animations.length);\r\n        this.updateArrayState(sortedArray, animations.length);\r\n    }\r\n\r\n    skipAnimations() {\r\n        const results = SortingAlgorithms.insertionSort(this.state.array.slice());\r\n        const sortedArray = results[1];\r\n\r\n        const arrayBars = document.getElementsByClassName('array-bar');\r\n        const buttons = document.getElementsByTagName('button');\r\n        const finishButton = document.getElementById('finish-button');\r\n        const sliders = document.getElementsByTagName('input');\r\n\r\n        for (let i = 0; i < TIMEOUTS.length; i++) {\r\n            clearTimeout(TIMEOUTS[i]);\r\n        }\r\n        for (let i = 0; i < this.state.numBars; i++) {\r\n            arrayBars[i].style.backgroundColor = PRIMARY_COLOR;\r\n        }\r\n        for (let i = 0; i < buttons.length; i++) {\r\n            buttons[i].disabled = false;\r\n        }\r\n        for (let i = 0; i < sliders.length; i++) {\r\n            sliders[i].disabled = false;\r\n        }\r\n\r\n        this.resetColors(arrayBars, 0);\r\n        this.setState({ array: sortedArray });\r\n    }\r\n\r\n    // Resets the bars used in the previous animation to the primary color and updates the colors of bars A and B. \r\n    updateColors(aStyle, bStyle, aColor, bColor, aStylePrev, bStylePrev, i) {\r\n        TIMEOUTS.push(setTimeout(() => {\r\n            aStylePrev.backgroundColor = PRIMARY_COLOR;\r\n            bStylePrev.backgroundColor = PRIMARY_COLOR;\r\n            aStyle.backgroundColor = aColor;\r\n            bStyle.backgroundColor = bColor;\r\n        }, i * this.state.animationSpeed));\r\n    }\r\n\r\n    // Swaps the heights of bars A and B.\r\n    swapBars(aStyle, bStyle, i) {\r\n        TIMEOUTS.push(setTimeout(() => {\r\n            let temp = aStyle.height;\r\n            aStyle.height = bStyle.height;\r\n            bStyle.height = temp;\r\n        }, i * this.state.animationSpeed));\r\n    }\r\n\r\n    // Resets the colors of all array bars to the primary color.\r\n    resetColors(arrayBars, numAnimations) {\r\n        TIMEOUTS.push(setTimeout(() => {\r\n            for (let i = 0; i < this.state.numBars; i++) {\r\n                arrayBars[i].style.backgroundColor = SORTED_COLOR;\r\n            }\r\n        }, numAnimations * this.state.animationSpeed));\r\n\r\n        TIMEOUTS.push(setTimeout(() => {\r\n            for (let i = 0; i < this.state.numBars; i++) {\r\n                arrayBars[i].style.backgroundColor = PRIMARY_COLOR;\r\n            }\r\n        }, (numAnimations * this.state.animationSpeed) + SORTED_MS));\r\n    }\r\n\r\n    // Temporarily disables buttons until sorting is complete.\r\n    disableButtons(numAnimations) {\r\n        const buttons = document.getElementsByTagName('button');\r\n        const finishButton = document.getElementById('finish-button');\r\n        const sliders = document.getElementsByTagName('input');\r\n\r\n        for (let i = 0; i < buttons.length; i++) {\r\n            buttons[i].disabled = true;\r\n        }\r\n        finishButton.disabled = false;\r\n        for (let i = 0; i < sliders.length; i++) {\r\n            sliders[i].disabled = true;\r\n        }\r\n\r\n        // Enables buttons after all animations have finished.\r\n        TIMEOUTS.push(setTimeout(() => {\r\n            for (let i = 0; i < buttons.length; i++) {\r\n                buttons[i].disabled = false;\r\n            }\r\n            for (let i = 0; i < sliders.length; i++) {\r\n                sliders[i].disabled = false;\r\n            }\r\n        }, (numAnimations * this.state.animationSpeed) + SORTED_MS));\r\n    }\r\n\r\n    // Updates the state once all animations have finished.\r\n    updateArrayState(sortedArray, numAnimations) {\r\n        TIMEOUTS.push(setTimeout(() => {\r\n            this.setState({ array: sortedArray });\r\n        }, numAnimations * this.state.animationSpeed));\r\n    }\r\n\r\n    // Tests the validity of all sorting algorithms.\r\n    testAlgorithms() {\r\n        /* Creates 100 random arrays of size 1 - 1000 with values ranging from -1000 - 1000, \r\n        sorts them using my sorting implementations and JavaScript's built-in sort, and \r\n        compares the two resulting arrays.\r\n        */\r\n        const testArrays = [];\r\n        for (let i = 0; i < 100; i++) {\r\n            let array = [];\r\n            const len = this.randomIntFromInterval(1, 1000);\r\n            for (let j = 0; j < len; j++) {\r\n                array.push(this.randomIntFromInterval(-1000, 1000));\r\n            }\r\n            testArrays[i] = array;\r\n        }\r\n\r\n        let testResults = [0, 0, 0, 0, 0];\r\n\r\n        for (let i = 0; i < 100; i++) { // Tests sorts on 100 unique arrays.\r\n            const javaScriptSort = testArrays[i].slice().sort((a, b) => a - b);\r\n            const bubbleSortArray = SortingAlgorithms.bubbleSort(testArrays[i].slice())[1];\r\n            const insertionSortArray = SortingAlgorithms.insertionSort(testArrays[i].slice())[1];\r\n            const selectionSortArray = SortingAlgorithms.selectionSort(testArrays[i].slice())[1];\r\n            const mergeSortArray = SortingAlgorithms.mergeSort(testArrays[i].slice())[1];\r\n            const quickSortArray = SortingAlgorithms.quickSort(testArrays[i].slice())[1];\r\n\r\n            // Increments corresponding value in testResults if implemented sort matches JavaScript's sort.\r\n            if (this.arraysAreEqual(javaScriptSort, bubbleSortArray)) testResults[0]++;\r\n            if (this.arraysAreEqual(javaScriptSort, insertionSortArray)) testResults[1]++;\r\n            if (this.arraysAreEqual(javaScriptSort, selectionSortArray)) testResults[2]++;\r\n            if (this.arraysAreEqual(javaScriptSort, mergeSortArray)) testResults[3]++;\r\n            if (this.arraysAreEqual(javaScriptSort, quickSortArray)) testResults[4]++;\r\n        }\r\n\r\n        console.log(\"Bubble Sort: \" + testResults[0] + \" correct\");\r\n        console.log(\"Insertion Sort: \" + testResults[1] + \" correct\");\r\n        console.log(\"Selection Sort: \" + testResults[2] + \" correct\");\r\n        console.log(\"Merge Sort: \" + testResults[3] + \" correct\");\r\n        console.log(\"Quick Sort: \" + testResults[4] + \" correct\");\r\n    }\r\n\r\n    // Determines whether two arrays are equal, taking order into account.\r\n    arraysAreEqual(a, b) {\r\n        if (a === b) return true;\r\n        if (a == null || b == null) return false;\r\n        if (a.length !== b.length) return false;\r\n\r\n        for (var i = 0; i < a.length; ++i) {\r\n            if (a[i] !== b[i]) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Generates a random integer from the given interval (inclusive min/max).\r\n    randomIntFromInterval(min, max) {\r\n        return Math.floor(Math.random() * (max - min + 1) + min);\r\n    }\r\n\r\n    updateAnimationSpeed = (e) => {\r\n        let value = parseInt(e.target.value);\r\n        this.setState({ animationSpeed: Math.pow(2, (-value + 14)) });\r\n    }\r\n\r\n    updateBars = (e) => {\r\n        let value = parseInt(e.target.value);\r\n        let newValue = parseInt(Math.pow(10, 1 + (value / 10)));\r\n        let newWidth = (90 / newValue) * .875;\r\n        let newMargin = ((90 / newValue) - newWidth) / 2;\r\n\r\n        this.setState({\r\n            numBars: newValue,\r\n            barWidth: newWidth,\r\n            barMargin: newMargin\r\n        });\r\n        this.resetArray(newValue);\r\n    }\r\n\r\n    render() {\r\n        const { array } = this.state;\r\n\r\n        return (\r\n            <div>\r\n                <header>\r\n                    <div id=\"title\">sorting visualizer</div>\r\n                </header>\r\n\r\n                <div id=\"top-controls\">\r\n                    <input className=\"range-selection\" type=\"range\" defaultValue=\"7\" min=\"3\" max=\"11\" step=\"2\" onInput={this.updateAnimationSpeed} />\r\n                    <button className=\"center-button\" onClick={() => this.resetArray(this.state.numBars)}>generate new array</button>\r\n                    <input className=\"range-selection\" type=\"range\" defaultValue=\"6\" min=\"2\" max=\"10\" step=\"2\" onInput={this.updateBars} />\r\n\r\n                    {/* <button className=\"center-button\" onClick={() => this.testAlgorithms()}>test algorithms</button> */}\r\n                </div>\r\n                <div className=\"array-container\">\r\n                    {array.map((value, idx) => (\r\n                        <div\r\n                            className=\"array-bar\"\r\n                            key={idx}\r\n                            style={{\r\n                                height: `${value}vh`,\r\n                                width: `${this.state.barWidth}vw`,\r\n                                margin: `${this.state.barMargin}vw`,\r\n                            }}\r\n\r\n                        ></div>\r\n                    ))}\r\n                </div>\r\n                <div>\r\n                    <button className=\"bottom-button\" onClick={() => this.bubbleSort()}>bubble</button>\r\n                    <button className=\"bottom-button\" onClick={() => this.insertionSort()}>insertion</button>\r\n                    <button className=\"bottom-button\" onClick={() => this.selectionSort()}>selection</button>\r\n                    <button className=\"bottom-button\" onClick={() => this.mergeSort()}>merge</button>\r\n                    <button className=\"bottom-button\" onClick={() => this.quickSort()}>quick</button>\r\n                    <button id=\"finish-button\" className=\"bottom-button\" onClick={() => this.skipAnimations()}>insta-sort!</button>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","import React from 'react';\nimport './App.css';\nimport SortingVisualizer from './SortingVisualizer/SortingVisualizer.jsx';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}